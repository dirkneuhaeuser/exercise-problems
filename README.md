

<p float="left">
 <img align="right" width="150" height="" src="https://onlinejudge.org/templates/hm_yaml_2_5/img/ojlogo2.svg.png">
 <img align="right" width="150" height="" src="https://www.saashub.com/images/app/service_logos/22/31099382e4b5/large.png?1545403232">
</p>



# Problems-List

This folder contains my solutions for problems on **Online-Judge(UVa)** and **kattis**.
They are mainly categorised according to their classification by **Competetive-Programming 4**.
This list is still uncomplete. I try to add all solved problems <br/> within this repository as soon as possible.




|Problem | Category | Solution | idea |
|-|-|-|-|
|[UVa00369 - Combinations](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=305)|Binomial coefficient|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/bin_coef/UVa00369_combinations.cpp) | Pascals formula for binomial coeficients|
|[UVa10541 - stripe](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1482)|Binomial coefficient|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/bin_coef/UVa10541_stripe.cpp) | First of all subtract from the possible white balls all the balls you already know where they will be (1 in between each black at least). For the rest, you can distribute them freely. Formula to put r elements in k bins: <img src="https://render.githubusercontent.com/render/math?math=\binom{r%2B k -1}{r}">|
|[UVa11955 - Binomial Theorem](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=3106)|Binomial coefficient|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/bin_coef/UVa11955_binomial_theorem.cpp) | String processing + Pascals formula for binomial coeficients|
|[UVa12712 - Pattern Locker](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=4450)|Binomial coefficient|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/bin_coef/UVa12712_pattern_locker.cpp) | <img src="https://render.githubusercontent.com/render/math?math=\binom{L \cdot L}{i}">, but keep track of permutation: <img src="https://render.githubusercontent.com/render/math?math=(\binom{L \cdot L}{i} \cdot i! = \frac{(L\cdot L)!}{(L\cdot L -i)!}">,  Also derivable via first one has <img src="https://render.githubusercontent.com/render/math?math=(L\cdot L)"> second one <img src="https://render.githubusercontent.com/render/math?math=(L\cdot L -1)"> |
|[kattis - Election](https://open.kattis.com/problems/election)|Binomial coefficient|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/bin_coef/kattis_election.cpp) | Pascals formula for binomial coeficients |
|[kattis - Tree Insertion](https://open.kattis.com/problems/insert)|Binomial coefficient|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/bin_coef/kattis_insert.cpp) | BST, Post-Order + Pascals formula for binomial coeficients but using bigint as n>66 |
|[kattis - Locked Treasure](https://open.kattis.com/problems/lockedtreasure)|Binomial coefficient|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/bin_coef/kattis_locked_treasure.cpp) | For each (m-1)-group, create key and give it to the rest|
|[kattis - Odd Binomial Coefficients](https://open.kattis.com/problems/oddbinom)|Binomial coefficient|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/bin_coef/kattis_odd_bin_coefs.cpp) | Print Pascals triangle mod 2 and find pattern. Eventually, you need to count all 1 in the upper triangel, up to row n|
|[kattis - Perica](https://open.kattis.com/problems/perica)|Binomial coefficient|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/bin_coef/kattis_perica.cpp) | Calculate the binomial Coefficient with Modulo: Precalculate the factorials and use mod-inverse|
|[UVa00991 - Safe Salutations](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=932)|Catalan Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/catalan/UVa00991_safe_salutations.cpp) | Hidden catalan numbers. |
|[UVa10007 - Count the Trees](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=948)|Catalan Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/catalan/UVa10007_count_the_trees.cpp) | Different trees: catalan numbers, Different order: n!. Use bigint, as n might be big. |
|[UVa10223 How Many Nodes?](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1164)|Catalan Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/catalan/UVa10223_how_many_nodes.cpp) | Hidden catalan numbers. |
|[UVa10312 - Expression Bracketing](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1253)|Catalan Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/catalan/UVa10312_expression_bracketing.cpp) | Super catalan numbers count the number of trees with n leaves and each inner node has >=2 children; there is a bijection from that tree to all possible bracketings (binary and non binary). Note, binary bracketing means ops(x1, x2) = ( x1, x2 ) - so two elemnts get transformed. Catalan numbers, on the other hand, count the binary bracketings, for example: (x(x(xx))). As both grow fast, use Bigint. |
|[kattis - Catalan Numbers](https://open.kattis.com/problems/catalan)|Catalan Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/catalan/kattis_catalan.cpp) | Catalan numbers for big n, use bigint. Note thate the groth of catalan numbers is approx <img src="https://render.githubusercontent.com/render/math?math=4^n">, thus long long will overflow for n>32 |
|[kattis - Catalan Square](https://open.kattis.com/problems/catalansquare)|Catalan Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/catalan/kattis_catalansquare.cpp) | Catalan numbers for big n, use bigint. Note thate the groth of catalan numbers is approx <img src="https://render.githubusercontent.com/render/math?math=4^n">, thus long long will overflow for n>32 |
|[kattis - fiat](https://open.kattis.com/problems/fiat)|Catalan Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/catalan/kattis_fiat.cpp) | Hidden catalan numbers. |
|[UVa00495 - Fibonacci Freeze](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=436)|Fibonacci Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/fibs/UVa00495_fibonacci_freeze.cpp) | Growth of Fibonacci approx. <img src="https://render.githubusercontent.com/render/math?math=2^n">. Therefore, if n>64, we need bigint. |
|[UVa00763 - Fibinary Numbers](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=704)|Fibonacci Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/fibs/UVa00763_fibinary_numbers.cpp) | Adding both numbers via Top-Down String processing method: Implement a method which can add a 1 at a specific index. |
|[UVa10334 - Ray Through Glasses](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1275)|Fibonacci Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/fibs/UVa10334_ray_through_colors.cpp) | Growth of Fibonacci approx. <img src="https://render.githubusercontent.com/render/math?math=2^n">. Therefore, if n>64, we need bigint. |
|[UVa10689 Yet Another Number Sequence](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1630)|Fibonacci Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/fibs/UVa10689_yet_another_problem.cpp) | Fibonacci Numbers with Modulo, make use of Pisano-Period to reduce computation. |
|[kattis - Batmanacci](https://open.kattis.com/problems/batmanacci)|Fibonacci Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/fibs/kattis_batmanacci.cpp) | The string size is still fibonacci long, so you can just simulate, where it will be after all. |
|[kattis - Interesting Integers](https://open.kattis.com/problems/interestingintegers)|Fibonacci Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/fibs/kattis_interesting_integers.cpp) | Let x and y be the <img src="https://render.githubusercontent.com/render/math?math=g_0"> and <img src="https://render.githubusercontent.com/render/math?math=g_1">, then the sequence woulde be: <img src="https://render.githubusercontent.com/render/math?math=x, y, x%2By, x%2B2y, 2x%2B3y, 3x%2B5y, 5x%2B8y, \ldots "> and hence the coefficients are again fibonacci. Therfore, for two consecutve fibonacci, find the coefficients s and t, s.t.  <img src="https://render.githubusercontent.com/render/math?math=s \cdot \text{fib}(i-1) %2B \cdot \text{fib}(i) = n ">. This again is a linear diophantine equation. |
|[kattis - Ocean's Anti-11](https://open.kattis.com/problems/anti11)|Fibonacci Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/fibs/kattis_oceans_anti_11.cpp) | Fibonacci with Modulo. |
|[kattis - Rijeƒçi](https://open.kattis.com/problems/rijeci)|Fibonacci Numbers|[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/fibs/kattis_rijeci.cpp) | Basic Fibonacci Problem |
|[UVa01224 - Tile Code](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=3665)|Harder Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_harder/UVa01224_tile_code.cpp) |  Count all possible and subtract all palindromes, then divide answer by two and add palindromes |
|[UVa10784_- Diagonal](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1725)|Harder Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_harder/UVa10784_diagonal.cpp) | Precalculate for each ngon for all possible n the number of diagonals. This is easy, as there are only two basic cases; n is even or odd |
|[UVa11069 - A Graph Problem](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=2010)|Harder Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_harder/UVa11069_a_graph_problem.cpp) | Basic DP |
|[UVa11538 - Chess Queen](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=2533)|Harder Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_harder/UVa11538_chess_queen.cpp) |  Count all possibilties. |
|[kattis - Anagram Counting](https://open.kattis.com/problems/anagramcounting)|Harder Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_harder/kattis_anagram_counting) | Multinomial Coefficent and Bigint |
|[kattis - Incognito](https://open.kattis.com/problems/incognito)|Harder Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_harder/kattis_incognito.cpp) |  Basic combinatorics |
|[kattis - Kitchen Combinatorics](https://open.kattis.com/problems/kitchencombinatorics)|Harder Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_harder/kattis_kitchencombinatorics.cpp) |  Text and number of plates and ingridients hight, but eventually it is just basic combinatorics |
|[kattis - Tri Tiling](https://open.kattis.com/problems/tritiling)|Harder Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_harder/kattis_tritiling.cpp) |  DP problem: dp[i][j] := how many ways you can end up in column i and use j to encode the missing pieces in the column i.|
|[UVa11310_- Delivery Debacle](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=2285)|Simple Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_simple/UVa11310_delivery_debacle.cpp) | New forms can be created by using last 4 (dp[i-2]) to create L shapes, you can use last 2 (dp[i-1]) to add two dots, you can use last 6 (dp[i-3]) to use two combined L shapes. |
|[UVa11401 - Triange_Couting](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=2285)|Simple Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_simple/UVa11401_triange_couting.cpp) | By taking two rods, check the condition for the 3rd rod.|
|[UVa12463 - Little Nephew](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=3906)|Simple Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_simple/UVa12463_little_nephew.cpp) | Basic combinatorics |
|[Uva11597 - Spanning Subtree](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=2644)|Simple Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_simple/Uva11597_spanning_subtree.cpp) | Basic combinatorics |
|[kattis - Character](https://open.kattis.com/problems/character)|Simple Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_simple/kattis_character.cpp) | Calculate binomical Coefficients with pascals' formula. |
|[kattis - honey](https://open.kattis.com/problems/honey)|Simple Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_simple/kattis_honey.cpp) | DP Problem; The difficulty is to get from the Honeycomb to a matrix |
|[kattis - Integer Division](https://open.kattis.com/problems/integerdivision)|Simple Combinatorics |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/combinatorics/others_simple/kattis_integer_division.cpp) | Basic Combinatorics |
|[UVa00350 - Pseudo Random Numbers](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1977)| Cycle-Finding |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/cycle_finding/UVa00350_pseudo_random_numbers.cpp) | Floyd's Cycle-Finding |
|[UVa11036 - Eventually Periodic Sequence](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1977)| Cycle-Finding |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/cycle_finding/UVa11036_eventually_periodic_sequence.cpp) | String processing + Floyd's Cycle-Finding |
|[UVa11053 - Flavius Josephus Reload](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1994)| Cycle-Finding |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/cycle_finding/UVa11053_flavius_josephus_reload.cpp) | Floyd's Cycle-Finding |
|[UVa11511 - Freeze Patterns](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=2506)| Cycle-Finding |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/cycle_finding/UVa11511_freeze_patterns.cpp) | freeze pattern will repeat very quickly -> do floyd's cycle detection on vectors |
|[kattis - Fibonacci Cycles](https://open.kattis.com/problems/fibonaccicycles)| Cycle-Finding |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/cycle_finding/kattis_fibonacci_cycles.cpp) | Floyd's Cycle Finding on the fibonacci numbers with mod; Or simply use Pisano-Period |
|[kattis - Happy Primes](https://open.kattis.com/problems/happyprime)| Cycle-Finding |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/cycle_finding/kattis_happy_primes.cpp) |Floyd's Cycle-Finding |
|[kattis - Party Game](https://open.kattis.com/problems/partygame)| Cycle-Finding |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/cycle_finding/kattis_party_game.cpp) | simulate problem |
|[kattis - Rats](https://open.kattis.com/problems/rats)| Cycle-Finding |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/cycle_finding/kattis_rats.cpp) | string processing |
|[LA6808 - Best Position](https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&category=672&page=show_problem&problem=4820)| Convolution |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/convolution/LA6808_best_position.cpp) | String Matching with Wildcards. Flatten the 2D array and then and add wildcards to the query, such that it has the same length as a row. |
|[atcoder - abc196F](https://atcoder.jp/contests/abc196/tasks/abc196_f)| Convolution |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/convolution/atcoder_bc196F.cpp) | Bitstring Matching. Match (1 and 1) and (0 and 0). 1 and 1 is easily matched by just the actual number 1. The multiplication then just add up to 1. For 0:0 we have to flip it and do it again. |
|[kattis - aplusb](https://open.kattis.com/problems/aplusb)| Convolution |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/convolution/kattis_aplusb.cpp) | Calculate frequencies convolution (all possible sums). Here numbers can be negative, thus shift all of them to the right. Also take into account the number of times a number gets projected onto itself by 0 (a_i + 0 = a_i or 0 + a_i = a_i, which is not allowed as not distinct. |
|[kattis - figurinefigures](https://open.kattis.com/problems/figurinefigures)| Convolution |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/convolution/kattis_figurinefigures.cpp) |  With <img src="https://render.githubusercontent.com/render/math?math=(f*f*f*f)"> we get the freqs of all possible 4-pack weights. As it is only important to us whether this weight is possible ( frequency >=1 ) or not (frq ==0 ) and as numbers a quite big, we compute first <img src="https://render.githubusercontent.com/render/math?math=(f*f)"> and recude all values greate than 1 to 1. |
|[kattis - golfbot](https://open.kattis.com/problems/golfbot)| Convolution |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/convolution/kattis_golfbot.cpp) | Basic convolution problem.  |
|[kattis - moretriangles](https://open.kattis.com/problems/moretriangles)| Convolution |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/convolution/kattis_moretriangles.cpp) | Complicated frequency convolution. For all a < n, calculate a^2(mod n) and add this to the frequency array. Afther this, do FFT-convultion 1 time and check if result itself is square (if it is in origin freq-array). Also, you need to take a<=b inta account: handle a==b separately and for the rest just divide by 2. |
|[kattis - polymul2](https://open.kattis.com/problems/polymul2)| Convolution |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/convolution/kattis_polymul2.cpp) | Basic polynomial multiplication. |
|[kattis - tiles](https://open.kattis.com/problems/tiles)| Convolution |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/convolution/kattis_tiles.cpp) | Complicated geometry + number-theory + convolution problem. The area A of a parallogram, which endpoints are all laying on the edges of a reactangle, can be coumputed by A=ac+bd. This can be seen as A = k + (A-k). Now for all k=1,...A-1 we have num_divs(k)*num_divs(A-k) possibilities. This is a normal convoltion formula, thus precalculate it once for all test-cases and then go through array to check for the answer. |
|[UVa10111 - Find The Winning Move](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1052)| Game Theory |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/game_theory/UVa10111_find_the_winning_move.cpp) | XXX |
|[UVa10536 - Game Of Euler](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1477)| Game Theory |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/game_theory/UVa10536_game_of_euler.cpp) | XXX |
|[UVa11489 - Integer Game](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=2484)| Game Theory |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/game_theory/UVa11489_integer_game.cpp) | XXX |
|[kattis - Bachets Game](https://open.kattis.com/problems/bachetsgame)| Game Theory |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/game_theory/kattis_bachets_game.cpp) | XXX |
|[kattis - Block Game](https://open.kattis.com/problems/blockgame2)| Game Theory |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/game_theory/kattis_block_game.cpp) | XXX |
|[kattis - Cutting Brownies](https://open.kattis.com/problems/cuttingbrownies)| Game Theory |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/game_theory/kattis_cutting_brownies.cpp) | XXX |
|[kattis - Euclids Game](https://open.kattis.com/problems/euclidsgame)| Game Theory |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/game_theory/kattis_euclids_game.cpp) | XXX |
|[kattis - Irrational Divison](https://open.kattis.com/problems/irrationaldivision)| Game Theory |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/game_theory/kattis_irrational_divison.cpp) | XXX |
|[kattis - Ivana](https://open.kattis.com/problems/ivana)| Game Theory |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/game_theory/kattis_ivana.cpp) | XXX |
|[kattis - Joyless Game](https://open.kattis.com/problems/joylessgame)| Game Theory |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/game_theory/kattis_joyless_game.cpp) | XXX |
|[kattis - Linije](https://open.kattis.com/problems/linije)| Game Theory |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/game_theory/kattis_linije.cpp) | XXX |
|[kattis - Multiplication Game](https://open.kattis.com/problems/multiplicationgame)| Game Theory |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/game_theory/kattis_multiplication_game.cpp) | XXX |
|[kattis - PEG Game For Two](https://open.kattis.com/problems/peggamefortwo)| Game Theory |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/game_theory/kattis_peg_game_for_two.cpp) | XXX |
|[UVa00820 - Internet Bandwith](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=761)| Maxflow - standard |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/standard/UVa00820_internet_bandwith.cpp) | Standard max flow, sink and target already given. Just compute max flow. |
|[UVa11167 - Monkeys in the Emei Mountain](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2108)| Maxflow - standard |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/standard/UVa11167_monkeys_in_the_emei.cpp) | Assignment Problem: If allocation possible, if so, generate possible allocation. |
|[UVa11418 - Clever Naming Patterns](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2413)| Maxflow - standard |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/standard/UVa11418_clever_naming_patterns.cpp) | Bipartite unweighted matching (MCBM): Numbers (A, B,...) to Problems. Titles are edges. |
|[UVa12873- The Programmers](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4738)| Maxflow - standard |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/standard/UVa12873_the_programmers.cpp) | Normal max flow/assignment problem (people to sites). |
|[kattis - Councilling](https://open.kattis.com/problems/councilling)| Maxflow - standard |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/standard/kattis_councilling.cpp) | Assignment problem. Structure of network: source, clubs, persons, vertex restrictions(again persons), parties, sink. |
|[kattis Jupiter Orbiter](https://open.kattis.com/problems/jupiter)| Maxflow - standard |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/standard/kattis_jupiter_orbiter.cpp) | Complex maxflow with back-coupling (to next time periods). Maxflow structure: source, sensor*times, queues*time (sum up previous and current), queues*time(vertex restriction: sum < cap), times (window restriction). |
|[kattis - Maximum Flow](https://open.kattis.com/problems/maxflow)| Maxflow - standard |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/standard/kattis_maximum_flow.cpp) | Normal Maxflow with edge extraction. |
|[kattis - Maze Movement](https://open.kattis.com/problems/mazemovement)| Maxflow - standard |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/standard/kattis_maze_movement.cpp) | Normal maxflow. Use GCD for checking the flow capacity. |
|[kattis - Minimum Cut](https://open.kattis.com/problems/mincut)| Maxflow - standard |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/standard/kattis_mincut.cpp) | Get left-partition of the Min-Cut: Dfs from source within resiudal-graph (over all non saturated edges). |
|[kattis - Piano](https://open.kattis.com/problems/piano)| Maxflow - standard |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/standard/kattis_piano.cpp) | Either use heap or Maxflow as it is an assignment problem (pianos to days). Important: MaxFlow problem become NP-hard if you need to add condition on edge to either use it to full capacity or not at all. E.g. piano needs to be delivered by two workers. However, these workes are not allowed to work on different days. If this is the case: try to model the problem differently. Here, we just use a weight of 1 instead of 2 and therfore the capacities of a single day by 2. |
|[kattis - RA-Duty-Scheduler](https://open.kattis.com/problems/dutyscheduler)| Maxflow - standard |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/standard/kattis_ra_duty_scheduler.cpp) | Maxflow assignment problem. Note the description is not correct: The input days are not unique. |
|[kattis - Tomography](https://open.kattis.com/problems/tomography)| Maxflow - standard |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/standard/kattis_tomography.cpp) | Match rows with columns, from source to row capacity row_sum, from col to sink with capacit col_sum and in between add edges between specific col and row for each cell they share. Note: This Problem gets now TLE with Maxflow, use greedy heap instead. |
|[kattis - Waif](https://open.kattis.com/problems/waif)| Maxflow - standard |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/standard/kattis_waif.cpp) | Basic maxflow assignment problem. |
|[kattis - Water](https://open.kattis.com/problems/water)| Maxflow - standard |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/standard/kattis_water.cpp) | Normal maxflow, but with dynamic edges: either reset all graph and change capacity OR just add new edge to used graph and the result is the gained difference.|
|[UVa00563 - Crimewave](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=504)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/UVa00563_crimewave.cpp) | As nodes can only be used once, we are looking for *independent paths*: Each vertex has a capacity of 1. We connect all banks to be robbed to the source, and all frame-out of city nodes to the sink. Note, Vertex capacity of 1 also implise edge capacity of 1, so we can actually mess with their capacity, I set it to INF, but 1 would also be ok. |
|[UVa11380 - Down Went The Titanic](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2375)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/UVa11380_down_went_the_titanic.cpp) |  A pure maxflow modelling problem. Note we don't need to bother that maximal 1 person can be on the iceberg at the same time, as people can just stay at their previsous place as long as possible. Also note that each node has a vertex capacity, flaoting ice and persons have 1, wood and icebergs have INF |
|[UVa11757 - Winger Trial](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2857)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/UVa11757_winger_trial.cpp) | Very creative geometric problem, given a field y_field x x_field, go from left to right with as few attackers possible. Therefore, let the bottom be the source, and the top be the sink. Build up the graph via the robotor nodes: Whenever two nodes intersect, then connect these in the mincut graph. Also all nodes which are at the bottom (y<=d) gets connected to source and all at the top (y>=y_field-d) get conected to sink. Note, you have to apply vertex capacity, as each robotor can only be used once: Now whenever you can can, connect source and sink, it is not possible to omit MinCut obstacles. |
|[UVa11765 Component Placement](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2865)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/UVa11765_component_placement.cpp) | Complicated min cut problem. Idea: Place bottlenecks of bottom and top components on opposite sides: Bottom elements have bottleneck towards the sorce and have INF capacity towards the sink. For Top elements vice versa. This set up alone will give us the cost for placing the elements when not considering the interconnection cost. Now an interconnection cost r can increase the min-cut(overall cost), iff connected with top and bottom elements: This way, we can use the INF part of either parts and thus increase by r. However, when the interconnection cost is in-between two components of the same side, then, the bottleneck will prevent an increase. |
|[kattis - avoidingtheapocalypse](https://open.kattis.com/problems/avoidingtheapocalypse)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_avoiding_the_apocalypse.cpp) | Max flow with time. In order to also reflect the time constraint, create (s+1) nodes for each location at each given time stamp (Blow up each vertex). When passing a road, then we pass to the specific target node in the future. |
|[kattis - Budget](https://open.kattis.com/problems/budget)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_budget.cpp) | Create flows from row sums to col sums via cells. In order to properly model '>', '<' and '=' you need to construct 2 graphs. The first will take care of all mandatory flows ('=' and if > x, then you also need at least a flow of x+1). The remaining row-sums can be allocated/flowed via another graph. Note you can't take the same graph, as then the algorithm might revoke some must flows. |
|[kattis - Chess Competition](https://open.kattis.com/problems/chesscompetition)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_chesscompetition.cpp) | For each team, let it win all opcoming matches and for the remaining matches do a max-flow: source, teams, matches, sink. Where the edge from source to the other teams has the capacity of the difference towards your highscore (they can not make more points than you in total). Then each team is connected to its opcoming matches (with capacity 2). If the maxflow can assign all points from all remaining matches, then you can win still |
|[kattis - Congest](https://open.kattis.com/problems/congest)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_congest.cpp) | Firstly get rid of all edges which are not otpmial, which means, they would lead to a detour (use SSSP-algorithm). Then create a max flow problem. Each each has a capacity of 1. To deal with the fact, that a road could be used more than once at different times, we repeat the maxflow for each possible dinstance towards the downtown. |
|[kattis - conveyorbelts](https://open.kattis.com/problems/conveyorbelts)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_conveyorbelts.cpp) |  Maxflow problem with time and modulo. Blow up each vertix k times (because we are interested in an always moving window of k; if a solution includes that product gets delivered at k+1, then it might be crashing with another product). Thus at each edge, deliver a product from t to (t+1) %k.|
|[kattis - Cops And Robbers](https://open.kattis.com/problems/copsandrobbers)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_cops_and_robbers.cpp) | Basic min-cut problem, add a frame (outter world) and add vertex capacity to each node. |
|[kattis - darkness](https://open.kattis.com/problems/darkness)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_darkness.cpp) | Very interesting Mincut (not vertex but the edge version). A fence between two cells is an bidrectional edge between them. Then from each dark cell you need to find the mincut to the frame. Greedily circle around all dark cells doesn't work here, as you might have some bright cells inside the dark territory which you better not fence up (like en enclave). Make the frame the sink and connect each dark field to the source with capacity INF. |
|[kattis - fakescoreboard](https://open.kattis.com/problems/fakescoreboard)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_fakescoreboard.cpp) | Repeated maxflow: Frist route the row-sums to col-sums accordingly. Now in order to get the lowest lexicographical order, we want to set N as early as possible. Therefore, we go through the grid and see if the edge between rowsum i and colsum j has been activated. If so, we reset it 0 (here is the actual problem of this problem, we can't brueforce all n*m - times the max flow. We are only allowed to reset a specific edges in order to keep us from TLE). So find the right index of all contributing edges (so from source to row i, from row i to col j and from col j to sink) and subtract 1 from forward flow and add 1 to backward flow. Now try dinic again. If the result is 1, then the network found an alternative way activating any cell after the current cell (as all the others have already been fixed). |
|[kattis - floodingfields](https://open.kattis.com/problems/floodingfields)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_floodingfields.cpp) | The cows need to survive at each time stamp. Blow each gridcell up with time. Connect each cell at t with itself at t+1 and its neighbours at t+1 only if the target cell is not floated. Also add vertix capacity in order to secure, that only 1 cow can be there at a given time. |
|[kattis - landscaping](https://open.kattis.com/problems/landscaping)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_landscaping.cpp) | The most difficult max flow problem for me. Connect all down-fields with source and all up fields with sink, both with capacity B. Now connect each neighboud element with capacity A. Each cell can then cause only B trouble and has the task to give the reamining flow to its neighbours. Two cases for higher fields (WLOG also for lower): **1. Case:** A higher field has less input flow than B, then transfer all of it to the sink (no changes) **2. Case:** A higher field has more input flow than B, then the field takes B and allocates the remaining toward its neighbours. Lets assume we only have one high neighbour. case 2.1 Remaining to this high neighbour is more than A: Send only A. The equivalent is, that the current high field will be changed to low field. case 2.2 Remining to this neighbour is less than A: Send less than A. The equivalent is, that the current high field stays high field (Its not worth it, as changing to a lower field will not get rid of the border between the now low and the still high neighbour field. |
|[kattis - marchofpenguins](https://open.kattis.com/problems/marchofpenguins)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_marchofpenguins.cpp) | Repeated Maxflow problem |
|[kattis - neutralground](https://open.kattis.com/problems/neutralground)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_neutralground.cpp) | Basic min-cut with vertex capacity. A is connected to source and B to sink. |
|[kattis - openpitmining](https://open.kattis.com/problems/openpitmining)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_open_pit_mines.cpp) | Add up the weights of all positve blocks. Then subtract the costs of using these positive blocks. That is caclulated via maxflow: Each block with pos. weight w, can only caus costs <= w. So connect all positive blocks to the source with weight w. Then add edges towards the obstacles with INF. Finally, connect all neg blocks with weight z to the sink with capcaity -z. The maxflow will give you then the total cost of adding all positve blocks, limited be not negative for each block (or rather synergy of blocks).|
|[kattis - thekingofthenorth](https://open.kattis.com/problems/thekingofthenorth)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_thekingofthenorth.cpp) | Basic min-cut problem. Here each location comes with a vertex capacity, given by the amount of people needed to defend that place. Connection all neighbours up to the frame, will lead to a correct min-cut result. Note, when having vertex-capacities, you actually need to connect each vertex with all 4 neighbours. It is not sufficient to connect from top to bottom and left to right. |
|[kattis - transportation](https://open.kattis.com/problems/transportation)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_transportation.cpp) | Very basic assignment problem. Assign transport companies to delivery routes. As they can only deliver from at most one state to another, use vertex capcacity.|
|[kattis - unfairplay](https://open.kattis.com/problems/unfairplay)| Maxflow - Variants |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/network_flow/variants/kattis_unfairplay.cpp) |  MaxFlow problem, assign each team its max. points in order to still lose and check if flow equals the total match points. Then, a simple inside view into the used edges (`get_used_backward_edges`) of each match will tell us, the winner or loser (assignment problem). |
|[UVa00481 - What Goes Up](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=422)| DP - LIS |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/LIS/UVa00481_what_goes_up.cpp) |  Basic LIS with reconstruction. |
|[UVa10534 - Wavio Sequence](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1475)| DP - LIS |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/LIS/UVa10534_wavio_sequence.cpp) |  Construct greedy LIS from left to right and from right to left (this equals LDS). Also, save for each number the current max increasing subsequence in a new vector. Then, greedily combine both and check where is the max. |
|[UVa11790 - Muricia's Skyline](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=2890)| DP - LIS |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/LIS/UVa11790_muricias_skyline.cpp) |  The normal greedy LIS in O(n*log(k)) here not possible as you can't override a previous higher building when it is wider. Therfore, just use the DP O(n^2) wher dpLIS[i] saves the comulated with if the sequence would end with the ith element |
|[UVa_01196 - Tiling Up Blocks](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=3637)| DP - LIS |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/LIS/UVa_01196_tiling_up_blocks.cpp) |  Sort the PIIs in the first dimension (and also second dimension after that - also ascending, as not stricly increasing) and do LIS in the second. Then any subsequence is alwyas increasing (not strictly here) in first dimension. And by appliying LIS with the numbers of second dimension we find that subsequence which is increasing in both. As not strictly increasing, use upper_bound. |
|[kattis - alphabet](https://open.kattis.com/problems/alphabet)| DP - LIS |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/LIS/kattis_alphabet.cpp) | Basis LIS problem. |
 |[kattis - increasingsubsequence](https://open.kattis.com/problems/increasingsubsequence)| DP - LIS |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/LIS/kattis_increasingsubsequence.cpp) |  LIS lexicographic order. To find lexicographically smalles, adjust end if possible to further behind, bc then you have more chances to have chosen smaller in general (more selection, and the greedy algo always take the smallest, overwriting of bigger ones) |
|[kattis - longincsubseq](https://open.kattis.com/problems/longincsubseq)| DP - LIS |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/LIS/kattis_longincsubseq.cpp) | Basic LIS with reconstruction (parent -vector) |
|[kattis - manhattanmornings](https://open.kattis.com/problems/manhattanmornings)| DP - LIS |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/LIS/kattis_manhattanmornings.cpp) |  2D LIS.  Sort in both dimension (fst dimension then snd dimension). Here not strictly increasing in both dimension, therefore ASC in both (othewise snd dimension DSC). Apply LIS on second dimension, as first dimension is already save increasing (its sorted). As not strictly increasing: user upper_bound not lower_bound |
|[kattis - nesteddolls](https://open.kattis.com/problems/nesteddolls)| DP - LIS |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/LIS/kattis_nesteddolls.cpp) | Complicated 2D LIS with multiset. Problem, we don't want to know the LIS, but the max. number of threads (or dolls, when as many smaller ones are in bigger ones). Consider each element in the multiset as a new thread. You can delete small doll-thread if you have a current bigger doll, as you can fit the smaller in the bigger one. However, you still insert a new thread (for the bigger one). Dolls need to be strictly bigger in both dimensions, thefore, sort ascending in first and descending in second.|
|[kattis - studentsko](https://open.kattis.com/problems/studentsko)| DP - LIS |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/LIS/kattis_studentsko.cpp) |  Find LIS, the elements which are not part of LIS need to be arranged. Issue: The order of within each team doesn't matter, so reset the talent of each student to its team-number, and then find LIS.|
|[kattis - trainsorting](https://open.kattis.com/problems/trainsorting)| DP - LIS |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/LIS/kattis_trainsorting.cpp) | You can put the car on the front -> increasing subsequence order (LIS), or you can put it to the back -> decreasing subsequence order (LDS). Restriciton: All elements from LDS need to be lower than all elements in LIS. Solution: Let w* be the frontier-weight to put cars either to left or right, simply try all w* out and for each calculate LIS and LDS accordingly |
|[UVa00787 - Maximum Subsequence Product](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=728)| DP - Kadane |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/range_sum/UVa00787_maximum_subsequence_product.cpp) |  Kadanes algorithm but keep track of two numbers, current-negative and current positive. If the overall result is 1, which is neutral element of multiplicaiton, then there are no positive elemnts >1 in array -> linear scan and find best single element. If elment is 0, restart from 1 |
|[UVa01105 - Coffee Central](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=3546)| DP - Kadane |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/range_sum/UVa01105_coffee_central.cpp) |  Complicated diagonal 2D-prefixsum. To test each field would timeout, as naive comes with <img src="https://render.githubusercontent.com/render/math?math=O((dx \cdot dy)^2)"> , Note the window in WC is bigger than dx or dy. Better Idea: For each cell, we need to test a certain cube. These cubes are very much overlapping. However, the diagonal nature of these cubes make it difficult to precalculate sums. Therefore, rotate each cell by 45 degees, such that you have normal rectangles. Now you can calculate a 2D Prefixsum, which is NOT kadane. In kadane we would only prefixsum over each row and then 'kadende' over all possible l and r column combination. Here, however, we do not need to look at windows of variable size. The window-size is fixed, so each cell we get in <img src="https://render.githubusercontent.com/render/math?math=O(1)"> with 2D Prefixsum, leading to overall <img src="https://render.githubusercontent.com/render/math?math=O(dx \cdot dy)"> |
|[UVa10684 - The Jackpot](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1625)| DP - Kadane |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/range_sum/UVa10684_the_jackpot.cpp) | Basic Kadane: Max range sum.|
|[UVa10755 - Garbage Heap](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1696)| DP - Kadane |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/range_sum/UVa10755_garbage_heap.cpp) | Prefixsum over the AB Planes for all C in <img src="https://render.githubusercontent.com/render/math?math=O(A B C)">, and then kadane over C for each rectangle size for in total in <img src="https://render.githubusercontent.com/render/math?math=O(A^2  B^2  C)">. Note: The result can't be empty: In Worst-Case, take the 'smallest' (from magnitude perspective) negative element. |
|[kattis - alicedigital](https://open.kattis.com/problems/alicedigital)| DP - Kadane |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/range_sum/kattis_alicedigital.cpp) |  1D Kadane with two numbers: no_m and one_m. In no_m we count while not having encountered a single m, and in one_m we count only when we already have a m found. We reset when we find a number smaller than m (m needs to be minimum) |
|[kattis - commercials](https://open.kattis.com/problems/commercials)| DP - Kadane |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/range_sum/kattis_commercials.cpp) |  Basic Kadane. |
|[kattis - foldedmap](https://open.kattis.com/problems/foldedmap)| DP - Kadane |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/range_sum/kattis_foldedmap.cpp) | There are only in total <img src="https://render.githubusercontent.com/render/math?math=Tr \cdot Tc">  many possibilites to start with the first tile. These tiles == fixed window => 2D Prefixsum over the map and try all <img src="https://render.githubusercontent.com/render/math?math=O(Tr \cdot Tc)">  in <img src="https://render.githubusercontent.com/render/math?math=O(n/Tr \cdot m/Tc)">  |
|[kattis - prozor](https://open.kattis.com/problems/prozor)| DP - Kadane |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/range_sum/kattis_prozor.cpp) | Here the size of the rack is given, so: 2D prefix sum and then you can check each of the O(a*b) potential racket fields in O(1).|
|[kattis - purplerain](https://open.kattis.com/problems/purplerain)| DP - Kadane |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/range_sum/kattis_purplerain.cpp) |  Kadane over two separate variables: The amount of R's and the amount of B's  |
|[kattis - sellingspatulas](https://open.kattis.com/problems/sellingspatulas)| DP - Kadane |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/range_sum/kattis_sellingspatulas.cpp) |  Very basic kadane. take care that the precision of the cout when printint the profit is correct.|
|[kattis - shortsell](https://open.kattis.com/problems/shortsell)| DP - Kadane |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/range_sum/kattis_shortsell.cpp) | Kadane over the Buying price, which must be as high as possible. Here, you also need to subtract the interest constantly. |
|[UVa01213 - Sum of Different Primes](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=3654)| DP - Knapsack |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/knapsack/UVa01213_sum_of_different_primes.cpp) | Knap sack with prime numbers as weight. As we can only have k items (and not as many as the weight allow), we need an additonal state. |
|[UVa10130 - superSale](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1071)| DP - Knapsack |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/knapsack/UVa10130_super_sale.cpp) | knapsack problem: `dp[j]` denotes the max value you can get having a weight of max j. Normally: `dp[i][j]` denotes the max value you can get having a weight of max j considering the first i objects, but this dimension is not really needed |
|[UVa11566 - Lets Yum Cha](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=2613)| DP - Knapsack |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/knapsack/UVa11566_lets_yum_cha.cpp) | Knapsack with restrictions (only 2*n dishes) -> new state, also each dish can be used 2 times |
|[UVa11832 - Account Book](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=2932)| DP - Knapsack |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/knapsack/UVa11832_account_book_TD.cpp) | Knapsack with offset and printing the solution. As the dp array is big in not all states are needed all the time, top-down would be better here.|
|[kattis - knapsack](https://open.kattis.com/problems/knapsack)| DP - Knapsack |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/knapsack/kattis_knapsack.cpp) | Basic Knapsack with solution retrieval |
|[kattis - muzicari](https://open.kattis.com/problems/muzicari)| DP - Knapsack |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/knapsack/kattis_muzicari.cpp) | It seems greedy, but in fact, it is a job-shop scheduling problem (np-hard), in which you want to minimise the makespan, s.t. it smaller/equal than T (duration of concert). If you take greedily, you might end up with 2 minutes left for both slots, but the last guy needs 4 miniutes of rest, which you can't split. Here: We do not need to minimise the make-span, only it hast to be lower than T. As there are only two pause-slots, the idea would be to utilize the first on as much as possible, s.t. the allocated pauses are in total <= T. We do this by knapsack-dp. Then we recover the solution, and all other dudes, will be assigned to the second slot. |
|[kattis - ninepacks](https://open.kattis.com/problems/ninepacks)| DP - Knapsack |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/knapsack/kattis_ninepacks.cpp) | Double Knapsack problem. Then, go trough all possible comulated weights in both dp (in last row), and minimise the sum over both |
|[kattis - orders](https://open.kattis.com/problems/orders)| DP - Knapsack |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/knapsack/kattis_orders.cpp) | Knapsack for reconstruction (without dimension reduction).|
|[kattis - presidentialelections](https://open.kattis.com/problems/presidentialelections)| DP - Knapsack |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/knapsack/kattis_presidentialelections.cpp) | Classical knapsack: items: states, weight: delegates, value to min.: votes|
|[UVa00674 - Coin Change](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=615)| DP - Coin Change |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/coin-change/UVa00674_coin_change.cpp) | Basic coin-change. It is very similar to knapsack, but we are not min./max. sth but, counting the possibilities. You need a dimension for the types (items in knapsack) and a state for current value (weight in knapsack) |
|[UVa11259 - Coin Change Again](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=2226)| DP - Coin Change |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/coin-change/UVa11259_coin_change_again.cpp) | Very complex infinite coin-change with inclusion-exclusion. Instead of prohibitive finite-coin change (which would be if d1 = 10^5 and v = 10^5 -> 10^10). Instead: Infinite coin change and make use of inclusion/exlusion princible to account for overcounting. For example the possibility to have d1+1 times the c1 coin needs to be subtracted. The same for d2 + 1times the c2 coin. However, then you need to add again when you have both (d1+1) times c1 and (d2+1) times c2. |
|[kattis - Bagoftiles](https://open.kattis.com/problems/Bagoftiles)| DP - Coin Change |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/coin-change/kattis_bagoftiles.cpp) | Basic coin-change dp + binomial coefficients |
|[kattis - Canonical](https://open.kattis.com/problems/Canonical)| DP - Coin Change |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/coin-change/kattis_canonical.cpp) | Basic coin-change dp + check if greedy works |
|[kattis - Exactchange2](https://open.kattis.com/problems/Exactchange2)| DP - Coin Change |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/coin-change/kattis_exactchange2.cpp) | Basic coin-change dp |
|[UVa11795 - Mega Man's Mission](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=2895)| DP - TSP, Hamiltonian Paths |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/TSE/UVa11795_mega_mans_mission.cpp) | Count all Hamiltonian Paths. Bitmask dp. `dp[mask]` := ways to kill the remaining robots in mask. Also here we are using 1 in the mask for 'has not been killed' because of LSOne(); |
|[UVa12841 - In Puzzleland](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=4706)| DP - TSP, Hamiltonian Paths |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/TSE/UVa12841_in_puzzleland.cpp) | Hemiltonian Path Problem. Find the lexicographically smallest solution, therefore, sort the bitmask, such that first bit(from right) stands for the smalles lexicographically value and when passing through the mask int the top-down held-karp algorithm we get the first set bit with LSOne, which automatically is the smallest possible lexicographically value for the current mask. Then just check if it is indead possible to go that way or abort. Also retrieve the solution afterwards. |
|[kattis - beepers](https://open.kattis.com/problems/beepers)| DP - TSP, Hamiltonian Paths |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/TSE/kattis_beepers.cpp) | Travelling Salesman Problem:  Mask only encodes the beepers (saving one bit), not the initial-position. Last encodes ALL positions, including the initial-position |
|[kattis - bustour](https://open.kattis.com/problems/bustour)| DP - TSP, Hamiltonian Paths |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/TSE/kattis_bustour.cpp) | More suffisicated TSP. The first half of the hotels need to be also in the first half on way back. Try all combinations for n/2 hotels in the first half (on the way towards the destination); 18 choose 9  = 48K differnt masks. Now we need to split the round into 4 different paths:  1. First n/2 hotls on the way towards destination, 2. Second n/2 hotls on the way towards destination, 3. First n/2 hotls on return, 4. Second n/2 hotls on return. NOTE: In order to use memo, the destination of the current path always needs to be same. Here the roads are bidrectional, so we structure the four paths in that way, that the destination is alywas either the start 0, or the destination n-1. NOTE: A good way to get permutations: use permutations of an 0-1 vector.|
|[kattis - cycleseasy](https://open.kattis.com/problems/cycleseasy)| DP - TSP, Hamiltonian Paths |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/TSE/kattis_cycleseasy.cpp) | Basic TSP Problem |
|[kattis - errands](https://open.kattis.com/problems/errands)| DP - TSP, Hamiltonian Paths |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/TSE/kattis_errands.cpp) | Basic hamiltonian path. |
|[kattis - maximizingyourpay](https://open.kattis.com/problems/maximizingyourpay)| DP - TSP, Hamiltonian Paths |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/TSE/kattis_maximizingyourpay.cpp) |  Find greatest hamiltionian cycle. Try all possible masks and check if there is a hamiltionian cycle. Note, we don't need to minimise anything, just possible or not possible to visit all. |
|[kattis - pokemongogo](https://open.kattis.com/problems/pokemongogo)| DP - TSP, Hamiltonian Paths |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/TSE/kattis_pokemongogo.cpp) | TSP Problem: Catch all unique pokemons and return to initial place. Problem: A pokemon can appear more then once. Try all masks and continue if the mask contains a pkm more than once or 0 times. |
|[kattis - race](https://open.kattis.com/problems/race)| DP - TSP, Hamiltonian Paths |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/TSE/kattis_race.cpp) | Hamiltionian Path Problem with deadline-restrictions on each node: Try all potential mask: If it is possible to have hamiltoninan path, save its value and go to next mask|
|[UVa10003 - Cutting Sticks](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=944)| DP - Level 1 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level1/UVa10003_cutting_sticks.cpp) | Classical log cutting dp. |
|[UVa10912 - Simple Minded Hash](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1853)| DP - Level 1 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level1/UVa10912_simple_minded_hash.cpp) | Basic dp with three states. `dp[i][j][k]` possibilities, after ith letter, after j letters in total used and got a hash of k |
|[UVa11420 - Chest Of Drawers](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=2415)| DP - Level 1 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level1/UVa11420_chest_of_drawers.cpp) | `dp[i][j][k]` := possibilities after the ith drawer(from above), which is unlocked(k=0)/locked(k=1) and after already having j secure drahers |
|[UVa13141 Growing Trees](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=871&page=show_problem&problem=5052)| DP - Level 1 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level1/UVa13141_growing_trees.cpp) | Fibonacci like dp|
|[kattis - keyboardconcert](https://open.kattis.com/problems/keyboardconcert)| DP - Level 1 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level1/kattis_keyboardconcert.cpp) | Basic dp |
|[kattis - nikola](https://open.kattis.com/problems/nikola)| DP - Level 1 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level1/kattis_nikola.cpp) | `dp[i][j]` the min entry fee, to get to square i, whereas the last jump has been of size j |
|[kattis - permutationdescent](https://open.kattis.com/problems/permutationdescent)| DP - Level 1 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level1/kattis_permutationdescent.cpp) | Difficult dp + permutation. States:  Order of the current permutation and the Descents already incorprated. Now, when increasing the order of the permuation, you have the biggest number of the hole sequence at your disposasl: 1. Not inceasing the number of descents. Therefore add the new number at the end or in an already existing descent. 2. Incease the number of descents and add number at the beginning or not in an already existing descent |
|[kattis - spiderman](https://open.kattis.com/problems/spiderman)| DP - Level 1 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level1/kattis_spiderman.cpp) | dp with reconsruction of solution. `dp[i][j]` := min building size after processing the ith training part and are at pos j; |
|[kattis - ticketpricing](https://open.kattis.com/problems/ticketpricing)| DP - Level 1 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level1/kattis_ticketpricing.cpp) |  `dp[i][j][0]` := max price after the ith week for j seats. |
|[kattis - weightofwords](https://open.kattis.com/problems/weightofwords)| DP - Level 1 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level1/kattis_weightofwords.cpp) | Coin change, possibility check. Restriction: n the number restriction (additional dimension). Note the same letter can be used multiple times -> infinite coin-change |
|[kattis - wordclouds](https://open.kattis.com/problems/wordclouds)| DP - Level 1 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level1/kattis_wordclouds.cpp) |  This dp requires top-down, only few states are actully computed. Even coming up with a complete memo array of 5000x1000x150 would be too large. Take a map as memo instead and use vector as state. |
|[UVa12324 - Philip J Fry Problem](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=3746)| DP - Level 2 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level2/UVa12324_philip_j_fry_problem.cpp) | Basic Top-Down |
|[UVa12862 - Intrepid Climber](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=4727)| DP - Level 2 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level2/UVa12862_intrepid_climber.cpp) |  DFS problem. Before we go to a certain child and add the cost towards it, wee need to know wether there is indead a friend in this subtree. As the hasSubtreeFriend function is maybe called often, we will memo it. |
|[UVa12955 - Factorial](https://onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&category=862&page=show_problem&problem=4834)| DP - Level 2 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level2/UVa12955_factorial.cpp) | As each factorial is a multiple of the smaller factorials, it is ok to greedily take the biggest factorial which fits into the current number. There is no advantage of skipping one factorial just to see if the next one yield an overall better result. As there are many test-cases: Use memo. |
|[kattis - debugging](https://open.kattis.com/problems/debugging)| DP - Level 2 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level2/kattis_debugging.cpp) | Top-Down DP. `dp[n]` The worst case time, when having n lines. At each state we try all possible printfs. Note when putting printf, you want them evenly distributed to minmise worst case. Take `ceil(n/(printfs+1))` for the next state. |
|[kattis - drivinglanes](https://open.kattis.com/problems/drivinglanes)| DP - Level 2 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level2/kattis_drivinglanes.cpp) | Classic dp problem. |
|[kattis - kutevi](https://open.kattis.com/problems/kutevi)| DP - Level 2 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level2/kattis_kutevi.cpp) | Just complete all possible values with a dfs and save values in a memo, such that query is fast. |
|[kattis - tight](https://open.kattis.com/problems/tight)| DP - Level 2 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level2/kattis_tight.cpp) | Simple dp. Similar to digit dp. Chose double as the solution might be very big. |
|[kattis - walrusweights](https://open.kattis.com/problems/walrusweights)| DP - Level 2 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level2/kattis_walrusweights.cpp) | Basic subset-sum |
|[kattis - watersheds](https://open.kattis.com/problems/watersheds)| DP - Level 2 |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/dp/dp_level2/kattis_watersheds.cpp) |  Rather a dfs than a dp excersie. |
|[UVa10090 Marbles](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1031)| Extended Euclidean |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/number_theory/extended_euclidian/UVa10090_marbles.cpp) |  Basic Linear Diophantine Equation. |
|[UVa10104 - Euclid Problem](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1045)| Extended Euclidean |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/number_theory/extended_euclidian/UVa10104_euclid_problem.cpp) | Compute B√©zout's coefficients.  |
|[UVa10633 - Rare Easy Problem](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1574)| Extended Euclidean |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/number_theory/extended_euclidian/UVa10633_rare_easy_problem.cpp) | Hidden Linear Diophantine Equation Problem: We can write <img src="https://render.githubusercontent.com/render/math?math=n = 10m %2B b">. If we denote `c = n-m`, then our equation is <img src="https://render.githubusercontent.com/render/math?math=9m %2B b = c">.|
|[UVa10673 - Play with Floor and Ceil](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=16&page=show_problem&problem=1614)| Extended Euclidean |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/number_theory/extended_euclidian/UVa10673_play_with_floor_and_ceil.cpp) | Basic Linear Diophantine Equation. |
|[kattis - candydistribution](https://open.kattis.com/problems/candydistribution)| Extended Euclidean |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/number_theory/extended_euclidian/kattis_candy_distribution.cpp) | Compute Inverse with Extended Euclidean with complicated edge cases. There are k kids and c candys per bag. Buy as many bags, s.t. you can distribute the candies fairly and have one over. Thus <img src="https://render.githubusercontent.com/render/math?math=cs - kt = 1">. Therefore, goal find: <img src="https://render.githubusercontent.com/render/math?math=c^{-1} (\mod k)">. Also possible: Linear Diophantine Equation. |
|[kattis - jughard](https://open.kattis.com/problems/jughard)| Extended Euclidean |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/number_theory/extended_euclidian/kattis_jug_hard.cpp) | Hidden Linear Diophantine Equation. Let jug one have a capacity of `a` and jug tow a capacity of `b`. You need to arrive at a level of `c` in one of the jugs. Thus by adding or subracting the levels we have the equation <img src="https://render.githubusercontent.com/render/math?math=as + bt = c">. Now, if `c` is divisiable by the GCD of a and b, then this linear diophantine equation has a solution (infinite). |
|[kattis - modulararithmetic](https://open.kattis.com/problems/modulararithmetic)| Extended Euclidean |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/number_theory/extended_euclidian/kattis_modular_arithmetic.cpp) | Basic Modular Arithmetic. Use euclidean algorithm to compute the inverse. |
|[kattis - soyoulikeyourfoodhot](https://open.kattis.com/problems/soyoulikeyourfoodhot)| Extended Euclidean |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/number_theory/extended_euclidian/kattis_pizza_hot.cpp) | Linear Diophantine Equation. Make doubles to integers by upgrading them to bigger numbers. |
|[kattis - wipeyourwhiteboards](https://open.kattis.com/problems/wipeyourwhiteboards)|Extended Euclidean |[c++](https://github.com/dirkneuhaeuser/exercise-problems/blob/master/number_theory/extended_euclidian/kattis_whipe_your_whiteboard.cpp) | Linear Diophantine Equation. |
